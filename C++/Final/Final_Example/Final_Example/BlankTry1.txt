1. 배열 vs 벡터

공통점: 연속된 공간에 저장됨. -> 임의 접근이 가능


배열 : 동적 할당 불가능
벡터 : 동적 할당 가능, -> 이 때문에 재할당, 파편화가 일어날 수 있음

2. 스택 vs 큐

공통점 : 각자 요소 삽입과 삭제에 O(N) 만큼의 시간이 듦

스택:
동작방식: LIFO, 

큐:
동작방식: FIFO

3. 링크드리스트 vs 어레이 혹은 벡터



연결리스트: 각 요소가 포인터로 연결, 임의접근 불가, 특정 위치에 삽입/삭제에 드는 비용이 벡터(어레이) 보다 훨씬 적다. 삽입 삭제는 O(1), 탐색은 O(N)

벡터: 연속된 공간에 저장, 임의 접근 가능, 맨 마지막 요소는 O(1)의 시간이 들지만, 그 이외의 경우의 삽입 삭제는 O(N), 탐색은 O(1)

4. 벡터

특징: 연속된 공간에 저장됨, 임의 접근 가능
단점: 
-> 삽입 삭제가 빈번할 경우 충분히 큰 사이즈를 잡지 않았을 때 재할당의 문제.
-> 중간에서 크기가 늘거나 줄어들 때 연속된 공간을 위한 재정렬의 문제


- 생성자



std::vector v(2);

-> 0 값을 2개 집어넣어준다.

std::vector v2(3, 50);

->50 값을 3개 집어넣어준다

- resize() vs reserve()

reserve는 이미 capacity가 reserve 값보다도 크다면 아무 일도 하지 않는다. 작을 경우 늘려줌.
resize는 capacity를 그대로 둔 채 요소를 비워낸다. size가 resize값보다 크다면, 맨 끝의 요소부터 삭제당함.




5. 맵

특징: 중복 되지 않는 키와, 키에 담기는 값을 갖는다. 키를 기준으로 정렬
단점: 정렬되는 특성 때문에 시간 복잡도에서 손해를 본다(레드-블랙 이진 트리)



std::pair를 쓴다.

std::pair 안에는 first, second 멤버변수가 존재. 각각 키와 값을 담는다.



6. 셋 vs 정렬 안 된 셋

셋: 밸런스드 바이너리 트리
정렬 안된 셋: 해시테이블을 쓴다.

해시맵과 맵의 차이와 대부분 같음.


7. 해시맵 vs 맵

맵: 레드-블랙 이진 트리 사용
해시맵: 해시테이블을 사용

정렬

8. STL 컨테이너들의 시간복잡도

스택(어레이)
삽입, 삭제 : 끝 부분의 경우 O(1), 중간 요소의 경우 최악은 O(N)
탐색: O(1)

맵(셋)
삽입, 삭제, 탐색: O(N)

리스트
삽입, 삭제: O(1)
탐색: O(N)

9. 반복자와 STL 알고리듬




10. 템플릿 프로그래밍 간단하게 작성

template<typename T, size_t N>
class Example
{
public:
	T Add(T t1, T t2);
	T Abstract(T t1, T t2);
private:
	T mArray[N];
};
//
template<typename T, size_t N>
T Example<T, N>::Add(T t1, T t2)
{
	return t1 + t2;
}

11. 이동 생성자

lvalue, rvalue 참고

&&

12. 이동 대입 연산자

lvalue, rvalue 참고

13. 새로운 키워드들(auto, static_assert, default/delete, final, override)

auto -> 데이터 타입을 추론해서 집어넣어줌.

-> 베스트 프랙티스 1: 반복자
-> 베스트 프랙티스 2: 
-> 사용하게 된다면 const, & 등은 꼭 붙이기.

14. 스마트 포인터

unique_ptr: 퍼포먼스 희생이 거의 없음. 명시적으로 포인터의 소유권을 알 수 있음.

shared_ptr: weak_ptr까지 들고 있어서 + 대입 연산에서 참조 횟수를 추적해야 해서
			참조가 자주 바뀔 때마다 오버헤드가 있음.
	weak_ptr: 순환 참조 해결을 위한 약한 참조.

15. 참조 카운팅 vs 가비지 컬렉션

참조 카운팅: 
	문제점:
		오버헤드: 매 대입 연산마다 참조 횟수가 늘고 주는 것을 추적해야 해서 오버헤드 발생

		순환참조: weak_ptr로 부분적 해결

가비지 컬렉션



	문제점:
		실시간, 고성능 프로그래밍이 필요한 곳에서 적합하지 않음.


16. lvalue vs rvalue
	int x = 15;
		x는 lvalue, 15는 rvalue
	x + 1 = 30;
		컴파일 에러. x + 1은 rvalue이기 때문
	*(x + 1) = 30;
		OK, (x + 1)의 포인터는 lvalue이기 때문

17. 람다 식

auto Lambda [](){};
[]는 catchblock
()는 매개변수를 받음
{}는 실행될 코드
맨 끝에는 mutex 가 붙을 수 있음.





13의 베스트 프랙티스 2, 베스트 프랙티스 3
15의 가비지 컬렉션 설명이 부족한 편.
16의 좀 더 사전적 의미도 적어넣으면 좋을 듯
17의 ()에 들어가는 사항이 맞는지?


13.
베스트 프랙티스 2
템플릿형 받기

auto* a = new std::vector<int>(5,30);

15. 
가비지 컬렉션
-- 사용되지 않는 메모리를 즉시 정리하지 않음.
-- GC가 메모리를 해제해야 하는지 판단하는 동안 애플리케이션이 멈추거나 버벅일 수 있음.

C++로 이걸 구현하려고 들다보면 C처럼 만들게 된다
-> 배열 같은거 만들어서 만든 거 안 지우고 박아뒀다가 다시 썼다가.. Lab9 참조.

참조 카운팅의 문제점

-> 멀티 스레드 환경에서는 순수한 포인터보다 훨씬 느림

17.
람다 식

[](){}

