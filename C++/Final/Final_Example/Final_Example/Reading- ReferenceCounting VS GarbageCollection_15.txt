- 참조 카운팅
 Swift와 애플 Objective-C 에서 지원

 --오브젝티브 C의 ARC?
 ARC(Automatic Reference Counting) - 게임업계에서 가끔 만들어서 썼던 방식
 오브젝트 쓰면 알아서 몇 번 참조되었는지 알고 지워줌. 

 --하복 엔진도 레퍼런스 카운팅 기반

 -- 가비지 컬렉션처럼, 개체에 대한 참조가 없을 때 개체가 해제됨
 -- 언제든 참조 횟수를 활용해서 특정 개체가 몇 번이나 참조되고 있는지 판단 가능
 -- 어떤 개체 A를 다른 개체 B가 참조할 때 횟수가 늘어남
 -- B가 참조를 그만둘 때 횟수 줄어듦
 예) B가 범위(Scope)를 벗어나는 경우



 -- 참조 카운팅의 문제점
 --- 참조횟수는 너무 자주 바뀜

 --- 순환 참조의 문제



- 가비지 콜렉션
 Java와 C#에서 지원

 -- 보통 트레이싱 가비지 컬렉션을 의미

 -- 메모리 누수를 막으려는 시도
 -- 주기적으로 컬렉션 실행
 -- 충분한 여유 메모리가 없을 때 컬렉션 실행
 -- 매 주기마다 GC는 루트 (root)를 확인함:
	--- 전역변수
	--- 스택
	--- 레지스터
		---- 힙에 있는 개체에 루트를 통해 접근할 수 있는지 판단
			접근할 수 없다면 가비지로 간주해서 해제.
	--- 루트?
-- 스택(루트)
C++의 경우 스택에서 힙으로 접근이 불가능한 것. -> 루트에서(스택에서) 접근이 불가능


- 가비지 컬렉션의 문제점

-- 사용되지 않는 메모리를 즉시 정리하지 않음.
-- GC가 메모리를 해제해야 하는지 판단하는 동안 애플리케이션이 멈추거나 버벅일 수 있음.

C++로 이걸 구현하려고 들다보면 C처럼 만들게 된다
-> 배열 같은거 만들어서 만든 거 안 지우고 박아뒀다가 다시 썼다가.. Lab9 참조.



가비지 컬렉션 vs 참조 카운팅

가비지 컬렉션
-> 사용하기 더 쉬움
-> 실시간 또는 고성능 프로그램에 적합하지 않음.

참조 카운팅
-> 여전히 사용하기 쉬움
-> 실시간 또는 고성능 프로그램에 적합
-> 멀티 스레드 환경에서는 순수한 포인터보다 훨씬 느림
